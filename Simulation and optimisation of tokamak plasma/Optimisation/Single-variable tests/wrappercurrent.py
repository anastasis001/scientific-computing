
import os
import numpy as np
import sys
import subprocess
import glob
from scipy.interpolate import RegularGridInterpolator


def findObjectiveFunctions(**kwargs):

    num_fns = kwargs['functions']

    x = kwargs['contVars']
    names = kwargs['contVarNames']
    ASV = kwargs['asv']

    retval = dict([])

    executable = "/home/aa2652/amrex/camrex/CAMREX.2d.gnu.MPI.ex"
    settingsFile =  "/home/aa2652/amrex/camrex/settings/tokamak/MAST"

    for var in range(len(x)):
        if names[var] == "current":
            r = x[var] 

    runCommand = f"mpirun -n 4 {executable} {settingsFile} "
    runCommand += "FreeBoundaryGS.current = " + str(r) + " "
    print(f"used r = {r}")
    

    with open("cmd.out", "w") as f:
        f.write(runCommand)

        
    #### additions to solve dyfunctional directories mismatch #####
    camrex_dir = "/home/aa2652/amrex/camrex"   # folder containing settings/, ITER/, …
    orig_dir   = os.getcwd()

    os.chdir(camrex_dir)                        # 1) go to CAMREX root

    print("Running simulation…")
    subprocess.run(runCommand, shell=True)   # 2) CAMREX solve

    #print("Post-processing …")
    subprocess.run("python3 simulationOutput/tokamak/safety.py", shell=True)  # 3) safety.py uses same cwd


    os.chdir(orig_dir)                          # 4) back to dakota_opt/


    try:
        with open("/home/aa2652/amrex/camrex/simulationOutput/tokamak/q95.txt") as f:
            q95 = float(f.readline())
            print(f"q95 = {q95}")
    except Exception as e:
        print("Failed to read q95:", e)
        q95 = 1000                      # or whatever penalty

    try:
        with open("/home/aa2652/amrex/camrex/simulationOutput/tokamak/beta.txt") as f:
            beta = float(f.readline())
    except Exception as e:
        print("Failed to read beta:", e)
        beta = 1000


    q95_pos = q95
    betapos = beta
    print(f"Assigning betapos = {betapos}")

    q95neg = -q95
    betaneg = -beta
    print(f"Assigning betaneg = {betaneg}")
    # Dakota expects both objectives on one line in results.out
    with open("results.out", "w") as f:
        f.write(f"{betaneg:.6f}\n")  
        print(f"After printing in results beraneg = {q95_pos}") # negate here

    # --------- Append evaluation to custom results file with header ---------
    log_file = "CurrentOptimisationResultsBeta.dat"

    # Combine variable names and values into a dictionary for clean formatting
    var_dict = dict(zip(names, x))


    print(f"Before writing log beta_pos = {betapos}")
    #Flag if this is a penalized evaluation
    write_header = not os.path.exists(log_file)
    #penalized = (q95_pos >= 9999.0 or beta_pos >= 9999.0)

    with open(log_file, "a") as f:
        if write_header:
            f.write("%eval_id interface " + " ".join(names) + " obj_fn\n")
        
        f.write(f"{0:<8} NO_ID      ")
        for name in names:
            f.write(f"{var_dict[name]:<14.6f}")
        f.write(f"{betapos:<12.6f}\n")
        print(f"After printing in log file q95_pos = {q95_pos}")
        
    return (beta)

def get_varvals():

    # Open the parameters file
    # This file is automatically generated, and has the structure:
    # <number> <description>
    # over a series of rows.  The row's are (TODO - clarify):
    # 'variables'            - Integer number of input variables
    # '<var 1>'                   - First variable
    # ...
    # '<var n>'                 - Final variable
    # 'functions'            - Number of objective functions
    # 'ASV_1:obj_fn'         - First objective function
    # ...
    # 'ASV_<n>:obj_fn'       - Final objective function
    # 'derivative_variables' - Number of derivative variables
    # 'DVV_1:<var 1>'             - First derivative variable
    # ...
    # 'DVV_<n>:<var n>'         - First derivative variable
    # 'analysis_components'  - number of ???
    # 'eval_id'              - which simulation id/number these results correspond to
    # 'metadata'             - presumably metadata exists for some models
    with open("params.in", "r") as f:
        paramsin = f.readlines()
        
    # Read the numerical values for the input variables
    # TODO - these should be able to accommodate arbitrary numbers of variables, since
    # the first argument gives this number
    x1 = None
    foundVariables = False
    # Large number to make sure we don't start accidentally reading variables early
    i = 10000
    for line in paramsin:
        if " variables" in line:
            # We have found the number of variables,
            numVar = int(line.split()[0])
            varVal = np.empty(numVar, dtype = object)
            varName = np.empty(numVar, dtype = object)
            foundVariables = True
            i = -1
        if i < numVar and i >= 0:
            print(line.split())
            varVal[i] = float(line.split()[0])
            varName[i] = line.split()[1]
        i = i+1
    print(varVal)                
    return varVal, varName


def pack_inputs(varVal, varName):
    d = {
        "functions": 1,
        "contVars": varVal,
        "contVarNames": varName,
        "asv": [1],
    }
    return d


def generate_output(varVal, varName, objFns):
    beta = objFns
    s = " Generating output for tokamak optimisation "
    for i in range(len(varVal)):
        s += f"\n  Input value for {varName[i]} = {varVal[i]}"
    s += f"\n Objective beta = {beta:.6f}\n"
    return s


def write_output(s):
    with open("teOptimisationOneVar.out", "w") as f:
        f.write(s)


def main():
    # Get the input variables
    varVal, varName = get_varvals()
    print(varVal)

    # Now assign these to appropriate vectors
    d = pack_inputs(varVal, varName)

    # Now call the function which runs the code and generates the objective functions
    objFns = findObjectiveFunctions(**d)
    # print(f)

    # Generate a string based on the input variables and objective functions for output
    s = generate_output(varVal, varName, objFns)
    # Output this to a file
    write_output(s)


if __name__ == "__main__":
    main()


